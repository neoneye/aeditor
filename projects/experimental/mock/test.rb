#!/usr/bin/ruby
# :nodoc: all
#
#	Test suite for Test::Unit::MockObject
#
#

$LOAD_PATH.unshift '.'

require 'test/unit'
require 'mock'

require 'utils'
include UtilityFunctions

### Set up a class to be mocked
class TestClass
	def initialize( arg1 )
		@arg1 = arg1
	end

	attr_accessor :arg1

	def first
		return "This is the first method"
	end

	def second( arg1 )
		return "This is the second method (#{arg1})"
	end

	def third( arg1, arg2="default" )
		return "This is the third method (#{arg1}, #{arg2})"
	end

	def fourth( arg1="default" )
		return "This is the fourth method (#{arg1})"
	end

	def fifth( *args )
		return "This is the fifth method (#{args.collect do |arg| arg.inspect end.join(',')})"
	end

end


### The test case
class TUMockTestCase < Test::Unit::TestCase

	# Testing and setup methods that are exected to be available from MockObject
	# instances. Does not include double-underscored and non-camelCased aliases,
	# which are auto-generated by the test.
	Interface = [
		# Setup methods
		:setReturnValues,
		:setCallOrder,
		:strictCallOrder=,
		:strictCallOrder?,

		# Testing methods
		:callTrace,
		:activate,
		:verify,
		:activate,
		:clear,
		:reset,
	]

	#################################################################
	###	C L A S S   M E T H O D S
	#################################################################

	@@methodCounter = 0
	@setupMethods = []
	@teardownMethods = []

	class << self
		attr_accessor :setupMethods
		attr_accessor :teardownMethods
	end

	
	### Append a setup block for the current testcase
	def self::addSetupBlock( &block )
		@@methodCounter += 1
		newMethodName = "setup_#{@@methodCounter}".intern
		define_method( newMethodName, &block )
		self.setupMethods.push newMethodName
	end


	### Prepend a teardown block for the current testcase
	def self::addTeardownBlock( &block )
		@@methodCounter += 1
		newMethodName = "teardown_#{@@methodCounter}".intern
		define_method( newMethodName, &block )
		self.teardownMethods.unshift newMethodName
	end


	#################################################################
	###	I N S T A N C E   M E T H O D S
	#################################################################

	### Set up a test before running
	def setup
		self.class.setupMethods.each {|sblock|
			self.send( sblock )
		}
	end
	alias_method :set_up, :setup

	### Tear down a test after it runs
	def teardown
		self.class.teardownMethods.each {|tblock|
			self.send( tblock )
		}
	end
	alias_method :tear_down, :teardown


	#################################################################
	###	T E S T   M E T H O D S
	#################################################################

	### Test to be sure the mockup class and factory method are loaded.
	def test_00_loaded
		assert_instance_of Class, Test::Unit::Mockup
		assert_respond_to Test::Unit, :MockObject
	end


	### Test mock object creation/interface
	def test_10_Constructor
		mockClass = nil
		mo = nil

		assert_nothing_raised { mockClass = Test::Unit::MockObject(TestClass) }
		assert_instance_of Class, mockClass
		
		assert_nothing_raised { mo = mockClass::new }
		assert_instance_of TestClass, mo
		assert_kind_of TestClass, mo
		assert mo.is_a?( TestClass ),
			"Mock object doesn't fake the is_a? method"
		assert mo.__class <= Test::Unit::Mockup,
			"Mock object real type not a Test::Unit::Mockup derivative"

		Interface.each {|meth|

			# Test the regular method and the double-underscore one.
			assert_respond_to mo, meth
			assert_respond_to mo, "__#{meth.to_s}".intern

			# Test for non-camelCased alias
			if /[A-Z]/ =~ meth.to_s
				# Oh, the irony.
				nonCamelCaseMethod = meth.to_s.gsub( /([A-Z])/ ) {|match|
					"_" + match.downcase
				}.intern

				assert_respond_to mo, nonCamelCaseMethod
			end

		}

		self.class.addSetupBlock {
			@mockObject = Test::Unit::MockObject(TestClass).new
		}
		self.class.addTeardownBlock {
			@mockObject = nil
		}
	end


	### Test the mocked methods
	def test_15_FakedMethods
		fakedMethod = nil
		rval = nil

		TestClass.instance_methods(false).each {|methName|
			realMethod = TestClass.instance_method( methName )
			
			assert_nothing_raised { fakedMethod = @mockObject.method(methName) }
			assert_instance_of Method, fakedMethod
			assert_equal realMethod.arity, fakedMethod.arity
		}

		@mockObject.activate

		# Now test calling with and without correct arity
		assert_raises( ArgumentError ) { @mockObject.first("foo") }
		assert_nothing_raised { @mockObject.first }

		assert_raises( ArgumentError ) { @mockObject.second }
		assert_nothing_raised { @mockObject.second("foo") }

		assert_raises( ArgumentError ) { @mockObject.third }
		assert_nothing_raised { @mockObject.third("foo") }

		assert_nothing_raised { @mockObject.fourth("foo") }
		assert_nothing_raised { @mockObject.fourth }

		assert_nothing_raised { @mockObject.fifth }
		assert_nothing_raised { @mockObject.fifth("foo") }
		assert_nothing_raised { @mockObject.fifth("foo", "bar", 1, 11, $stderr, 1..18) }

		# Test for call trace
		assert_nothing_raised { rval = @mockObject.callTrace }
		assert_instance_of Array, rval
		assert_equal 8, rval.length

		debugMsg "Call trace: "
		rval.each {|trace| debugMsg trace}

	end


	### Test the methods that aren't mocked (those that aren't already tested
	### above)
	def test_17_UnmockedMethods
		rval = nil

		# inspect
		assert_nothing_raised { rval = @mockObject.inspect }
		assert_match( /#<Class:0x[a-f0-9]+>:0x[a-f0-9]+ /, rval )

		# class
		assert_nothing_raised { rval = @mockObject.class }
		assert_equal TestClass, rval

		# method, send, respond_to?
		assert_nothing_raised { rval = @mockObject.send(:inspect) }
		assert_not_nil rval
		assert_nothing_raised { rval = @mockObject.method(:inspect) }
		assert_instance_of Method, rval
		assert_nothing_raised { rval = @mockObject.respond_to?(:fifth) }
		assert_equal true, rval
	end


	### Test the mock setup methods
	def test_20_SetupMethods
		assert_nothing_raised {
			@mockObject.setReturnValues( :first	=> 1,
										 :second => 2,
										 :third => 3 )
		}
		assert_nothing_raised {
			@mockObject.setReturnValues( :fourth => 4,
										 :second => 'II' )
		}

		assert_equal 1, @mockObject.first
		assert_equal 'II', @mockObject.second(:foo)
		assert_equal 3, @mockObject.third(:foo)
		assert_equal 4, @mockObject.fourth
		assert_equal true, @mockObject.fifth
	end


	### Test the call-order verification with "strict" mode turned off
	def test_30_TestCallOrder
		assert_nothing_raised {
			@mockObject.setCallOrder( :first, :second, :third, :fourth, :fifth )
		}

		# Test a successful run with an extra call
		assert_raises( RuntimeError ) { @mockObject.verify }
		assert_nothing_raised { @mockObject.activate }

		@mockObject.first
		@mockObject.second(:foo)
		@mockObject.arg1
		@mockObject.third(:foo)
		@mockObject.fourth
		@mockObject.fifth

		assert_raises( RuntimeError ) { @mockObject.activate }
		assert_nothing_raised { @mockObject.verify }

		# Test a failure
		@mockObject.clear
		@mockObject.activate

		@mockObject.first
		@mockObject.second(:foo)
		@mockObject.arg1
		@mockObject.fourth
		@mockObject.fifth

		assert_raises( Test::Unit::AssertionFailedError ) { @mockObject.verify }
	end


	### Test call-order verification with "strict" mode turned on
	def test_35_TestStrictCallOrder
		@mockObject.setCallOrder( :first, :second, :third, :fourth, :fifth )
		assert_nothing_raised { @mockObject.strictCallOrder = true }

		# Test a failure: an extra method
		@mockObject.activate

		@mockObject.first
		@mockObject.second(:foo)
		@mockObject.arg1
		@mockObject.third(:foo)
		@mockObject.fourth
		@mockObject.fifth

		assert_raises( Test::Unit::AssertionFailedError ) { @mockObject.verify }

		# Test a failure for a missing method
		@mockObject.clear
		@mockObject.activate

		@mockObject.first
		@mockObject.second(:foo)
		@mockObject.arg1
		@mockObject.fourth
		@mockObject.fifth

		assert_raises( Test::Unit::AssertionFailedError ) { @mockObject.verify }
	end

	class Dummy
		def lookup(x, y)
			nil
		end
		def status
			nil
		end
	end
	def test_return_values_with_proc_in_array
		obj = Test::Unit::MockObject(Dummy).new 
		obj.set_return_values(
			:status => [1, 2, lambda{raise "boom"}, 3]
		)
		obj.activate
		assert_equal(1, obj.status)
		assert_equal(2, obj.status)
		e = assert_raise(RuntimeError) { obj.status }
		assert_match(/boom/, e.message)
		assert_equal(3, obj.status)
		assert_equal(1, obj.status)
		obj.verify
	end
	def test_return_values_with_proc_in_hash
		obj = Test::Unit::MockObject(Dummy).new 
		obj.set_return_values(
			:lookup => {[1, -1]=>10, [2, -2]=>20, [3, -3]=>lambda{raise "boom"}}
		)
		obj.activate
		assert_equal(10, obj.lookup(1, -1))
		assert_equal(20, obj.lookup(2, -2))
		e = assert_raise(RuntimeError) { obj.lookup(3, -3) }
		assert_match(/boom/, e.message)
		assert_equal(nil, obj.lookup(4, -4))
		obj.verify
	end
end

